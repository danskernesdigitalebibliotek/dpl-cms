<?php

/**
 * @file
 * Module file for DPL Event.
 */

use Drupal\Core\Datetime\DrupalDateTime;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\FieldableEntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Url;
use Drupal\dpl_event\EventState;
use Drupal\file\Entity\File;
use Drupal\job_scheduler\Entity\JobSchedule;
use Drupal\media\Entity\Media;
use Drupal\recurring_events\Entity\EventInstance;
use Drupal\recurring_events\Entity\EventSeries;
use Safe\DateTimeImmutable;

/**
 * Implements hook_cron_job_scheduler_info().
 *
 * @return non-empty-array<string, array{'worker callback': string}>
 *   Job scheduler information.
 */
function dpl_event_cron_job_scheduler_info(): array {
  return [
    "dpl_event_set_occurred" => [
      "worker callback" => 'dpl_event_set_occurred_callback',
    ],
  ];
}

/**
 * Implements hook_node_insert().
 */
function dpl_event_eventinstance_insert(EntityInterface $entity): void {
  if ($entity instanceof EventInstance && dpl_event_eventinstance_is_active($entity)) {
    dpl_event_schedule_set_occurred($entity);
  }
}

/**
 * Implements hook_node_update().
 */
function dpl_event_eventinstance_update(EntityInterface $entity): void {
  if ($entity instanceof EventInstance && dpl_event_eventinstance_is_active($entity)) {
    dpl_event_schedule_set_occurred($entity);
  }
}

/**
 * Determine if an event is considered active.
 *
 * An event is considered active if it has not occurred or been cancelled.
 */
function dpl_event_eventinstance_is_active(EventInstance $event): bool {
  $event_states = array_map(function (array $sfield_value) : EventState {
    return EventState::from($sfield_value['value']);
  }, $event->get("event_state")->getValue());

  return !(in_array(EventState::Cancelled, $event_states)
    || in_array(EventState::Occurred, $event_states));
}

/**
 * Schedule setting an event to occurred in the future.
 */
function dpl_event_schedule_set_occurred(EventInstance $event): void {
  $now_timestamp = \Drupal::time()->getCurrentTime();

  $event_date = $event->get('date')->get(0);
  if (!$event_date) {
    return;
  }
  $event_date_values = $event_date->getValue();
  if (!$event_date_values || empty($event_date_values["end_value"])) {
    return;
  }
  $event_end_date = new DateTimeImmutable($event_date_values["end_value"]);
  $event_end_timestamp = $event_end_date->getTimestamp();

  $job = [
    'name' => 'dpl_event_set_occurred',
    'type' => 'event',
    'id' => $event->id(),
    // The period is the number of seconds to wait between job executions. A
    // negative period means that the job will be executed as soon as
    // possible. By setting periodic false the job is only executed once.
    'period' => $event_end_timestamp - $now_timestamp,
    'periodic' => FALSE,
  ];

  /** @var \Drupal\job_scheduler\JobSchedulerInterface $scheduler */
  $scheduler = \Drupal::service('job_scheduler.manager');
  // Remove any preexisting job with the same name, type and id.
  $scheduler->remove($job);
  // Schedule the new update.
  $scheduler->set($job);

  \Drupal::logger('dpl_event')->debug(
    'Scheduled "occurred" update for event %event_id at %end_time',
    ['%event_id' => $event->id(), '%end_time' => $event_end_date->format('c')]
  );
}

/**
 * Callback to be executed for scheduled jobs.
 */
function dpl_event_set_occurred_callback(JobSchedule $job): void {
  $event = \Drupal::entityTypeManager()->getStorage('eventinstance')->load($job->getId());
  if (!$event || !$event instanceof EventInstance) {
    return;
  }

  // Set state to occurred for events we consider active.
  if (dpl_event_eventinstance_is_active($event)) {
    $event->set("field_event_state", EventState::Occurred);
    $event->save();
  }
}

/**
 * Implements hook_preprocess_HOOK() for field templates.
 *
 * Preprocesses the 'field_event_link' for Drupal entities to alter its display
 * based on the event's state. It updates the button title and sets an
 * 'event_is_active' flag depending on the event state.
 */
function dpl_event_preprocess_field(array &$variables): void {
  // Get the field name from the variables array. Default to NULL if not set.
  $field_name = $variables['field_name'] ?? NULL;

  if (!in_array($field_name, ['field_event_link', 'event_link']) ||
    empty($variables['items'][0]['content']['#title'])) {
    return;
  }

  $entity = $variables['element']['#object'] ?? NULL;
  if (!($entity instanceof FieldableEntityInterface)) {
    return;
  }

  // Try to retrieve the event state field for the entity.
  // Prefer field_event_state which is the direct value on series or instances
  // over event_state which is fallback value for instances from series.
  if ($entity->hasField('field_event_state') && !$entity->get('field_event_state')->isEmpty()) {
    $event_state_field = $entity->get('field_event_state');
  }
  elseif ($entity->hasField('event_state') && !$entity->get('event_state')->isEmpty()) {
    $event_state_field = $entity->get('event_state');
  }
  else {
    throw new LogicException('Unable to retrieve state field for event');
  }

  $event_states = array_map(function (array $sfield_value) {
    return EventState::from($sfield_value['value']);
  }, $event_state_field->getValue());
  $event_state = $event_states[0] ?? NULL;

  // Check if the event state is valid. If not, return early.
  if (!($event_state instanceof EventState)) {
    return;
  }

  // Set 'event_is_active' flag if event state is neither of the following.
  $variables['event_is_active'] = !in_array($event_state, [
    EventState::Occurred,
    EventState::Cancelled,
    EventState::SoldOut,
    EventState::TicketSaleNotOpen,
  ]);

  // After determining the 'event_is_active' flag, check if the event is active.
  if ($variables['event_is_active']) {
    // If active, set a translatable string as the title.
    $variables['items'][0]['content']['#title'] = t('Buy tickets');
    return;
  }
  else {
    // Update the title of the button to the label of the current event state.
    $variables['items'][0]['content']['#title'] = $event_state->label();
  }
}

/**
 * Implements hook_preprocess_field__field_ticket_category_price().
 *
 * Adds an array of formatted prices.
 */
function dpl_event_preprocess_field__field_ticket_category_price(array &$variables) : void {
  /** @var \Drupal\dpl_event\PriceFormatter $price_formatter */
  $price_formatter = \Drupal::service('dpl_event.price_formatter');
  /** @var \Drupal\Core\Field\FieldItemListInterface $items */
  $items = $variables['element']['#items'];
  $prices = array_map(function (array $price) use ($price_formatter): string {
    return $price_formatter->formatPrice($price["value"]);
  }, $items->getValue());
  $variables['prices'] = $prices;
}

/**
 * Implement hook_preprocess() for event series.
 */
function dpl_event_preprocess_eventseries(array &$variables): void {
  $event_series = $variables['eventseries'] ?? NULL;

  if (!($event_series instanceof EventSeries)) {
    return;
  }

  $variables['formatted_date'] =
    \Drupal::service('dpl_event.reoccurring_date_formatter')
      ->getSeriesDateString($event_series);
}

/**
 * Implements hook_preprocess_HOOK() for node templates.
 *
 * Preprocesses variables for node templates.
 *
 * Includes generating ticket pricing display in 'event_list_teaser' view mode.
 *
 * @param mixed[] $variables
 *   The variables array for the node template.
 *
 * @throws \Safe\Exceptions\ArrayException
 */
function dpl_event_preprocess_eventinstance(array &$variables): void {

  $eventInstance = $variables['eventinstance'];

  if ($eventInstance->hasField('event_ticket_categories')) {
    $ticket_categories = $eventInstance->get('event_ticket_categories')->referencedEntities();
    $prices = [];
    // Collect prices from ticket categories.
    foreach ($ticket_categories as $category) {
      if ($category->hasField('field_ticket_category_price') && !$category->get('field_ticket_category_price')->isEmpty()) {
        $prices[] = $category->get('field_ticket_category_price')->value;
      }
    }

    // Get the PriceFormatter service.
    $price_formatter = \Drupal::service('dpl_event.price_formatter');
    $variables['ticket_price_display'] = $price_formatter->formatPriceRange($prices);
  }
}

/**
 * Implements hook_gin_content_form_routes().
 *
 * @return string[] An array of event-related routes which should be managed as
 *   content forms by the Gin theme.
 */
function dpl_event_gin_content_form_routes() : array {
  return [
    'entity.eventseries.add_form',
    'entity.eventseries.edit_form',
    // There is no direct add form for instances. They are always created in
    // relation to series.
    'entity.eventseries.add_instance_form',
    'entity.eventinstance.edit_form',
  ];
}

/**
 * Implements hook_preprocess_eventinstance__list_teaser().
 *
 * Preprocesses variables for the 'list_teaser' view mode of eventinstance.
 * - Generating the URL for the full view of the event instance.
 * - Extracting image URL and alt text from the 'event_image' field.
 * - Processing start and end dates from the 'date' field and formatting them
 *   in the site's timezone.
 */
function dpl_event_preprocess_eventinstance__list_teaser(array &$variables): void {
  $eventInstance = $variables['eventinstance'];
  /** @var \Drupal\Core\Datetime\DateFormatterInterface $date_formatter */
  $date_formatter = \Drupal::service('date.formatter');

  // Extract the event url.
  $variables['eventinstance_url'] = Url::fromRoute('entity.eventinstance.canonical', ['eventinstance' => $eventInstance->id()])->toString();

  // Extract image file URL and alt text.
  if ($eventInstance->hasField('event_image') && !$eventInstance->get('event_image')->isEmpty()) {
    $media_entity = $eventInstance->get('event_image')->entity;
    if ($media_entity instanceof Media && $media_entity->bundle() == 'image' && !$media_entity->field_media_image->isEmpty()) {
      $file = $media_entity->field_media_image->entity;
      if ($file instanceof File) {
        $variables['image_file_url'] = $file->createFileUrl(FALSE);
        $variables['image_alt'] = $media_entity->field_media_image->alt ?? '';
      }
    }
  }

  // Extract start_date, end_date and datetime attributes.
  if (!$eventInstance->get('date')->isEmpty()) {
    $date_field = $eventInstance->get('date')->first();

    $start_date = $date_field->start_date;
    $end_date = $date_field->end_date;

    if ($start_date instanceof DrupalDateTime) {
      $variables['start_date'] = $date_formatter->format($start_date->getTimestamp(), 'custom', 'H:i');
      $variables['datetime_attribute'] = $date_formatter->format($start_date->getTimestamp(), DATE_ATOM);
    }
    if ($end_date instanceof DrupalDateTime) {
      $variables['end_date'] = $date_formatter->format($end_date->getTimestamp(), 'custom', 'H:i');
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Altering the form for EDITING (not creating) an event series.
 */
function dpl_event_form_eventseries_default_edit_form_alter(array &$form, FormStateInterface $form_state): void {
  // When saving a series, and changing the dates, the recurring_events module
  // will make a "custom" submit button, showing a 'are you sure' button.
  // However, this does not include a 'cancel' button. This is because cancel
  // basically just means navigating away, but, this is confusing for editors.
  // We'll add our own "button", that is really just a link the same edit page.
  if (!empty($form['diff']['confirm'])) {
    $form['diff']['cancel'] = [
      '#type' => 'link',
      '#title' => t('Cancel all changes', [], ['context' => 'DPL admin UX']),
      '#url' => Url::fromRoute('<current>'),
      '#attributes' => [
        'class' => [
          'action-link', 'action-link--danger', 'action-link--icon-trash',
        ],
      ],
    ];

    // The save/delete buttons on the page does nothing, when a diff confirm
    // is relevant. We'll hide them, just to make it less confusing for the
    // editors.
    unset($form['actions']);
  }
}
